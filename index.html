dash<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Salalah Project Progress </title>
<meta name="viewport" content="width=device-width, initial-scale=1" />


<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css">
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>


<script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>


<script src="https://cdn.jsdelivr.net/npm/proj4@2.9.2/dist/proj4.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
  :root{
 
    --bg: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
    --panel: rgba(255, 255, 255, 0.5);
    --panel2: linear-gradient(135deg, rgba(255,255,255,0.45) 0%, rgba(247,250,252,0.45) 100%);
    --border: rgba(255, 255, 255, 0.3);
    --text: #1a202c;
    --muted: #4a5568;
    --accent: #667eea;
    --accent2: #764ba2;

   
    --processed: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --remaining: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    --outline: rgba(102, 126, 234, 0.3);

 
    --fs: clamp(16px, 1.2vw + 12px, 22px);
    

    --shadow-sm: 0 2px 8px rgba(0,0,0,0.08);
    --shadow-md: 0 4px 16px rgba(0,0,0,0.12);
    --shadow-lg: 0 8px 32px rgba(0,0,0,0.16);
    --shadow-xl: 0 16px 48px rgba(0,0,0,0.2);
  }

  *{ box-sizing:border-box }
  html, body { height:100%; }
  body{
    margin:0; color:var(--text);
    background: var(--bg);
    background-attachment: fixed;
    font: var(--fs)/1.55 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
    overflow-y:auto; overflow-x:hidden;
    position: relative;
  }
  
  body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
      radial-gradient(circle at 20% 50%, rgba(102, 126, 234, 0.1) 0%, transparent 50%),
      radial-gradient(circle at 80% 80%, rgba(118, 75, 162, 0.1) 0%, transparent 50%),
      radial-gradient(circle at 40% 20%, rgba(245, 87, 108, 0.05) 0%, transparent 50%);
    pointer-events: none;
    z-index: 0;
  }

  header{
    height:72px; display:flex; align-items:center; justify-content:space-between; gap:10px;
    padding:0 24px; 
    background: rgba(255, 255, 255, 0.5);
    backdrop-filter: blur(20px) saturate(180%);
    border-bottom: 1px solid rgba(255, 255, 255, 0.35);
    box-shadow: 0 4px 24px rgba(0,0,0,0.08);
    font-weight: 800;
    font-size: 24px;
    color: #1a202c;
    position: relative;
    z-index: 10;
  }
  
  header span {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-size: 26px;
    letter-spacing: -0.5px;
  }

  .app{
    height: calc(100vh - 72px);
    min-height: calc(100dvh - 72px);
    display:grid; gap:20px; padding:20px;
    grid-template-columns: 1.7fr 1fr;
    overflow:hidden;
    position: relative;
    z-index: 1;
  }
  .hidden{ visibility:hidden; }

  .card{
    background: var(--panel);
    border: 1px solid rgba(255, 255, 255, 0.5);
    border-radius: 20px;
    box-shadow: var(--shadow-xl);
    padding: 20px; 
    display:flex; 
    flex-direction:column; 
    min-width:0;
    backdrop-filter: blur(10px);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }
  
  .card:hover {
    transform: translateY(-2px);
    box-shadow: 0 20px 60px rgba(102, 126, 234, 0.15);
  }
  
  .card h4{ 
    margin: 0 0 16px 0; 
    font-weight: 800; 
    font-size: 26px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: -0.3px;
  }

 
  #mapAssets{ 
    flex:1 1 auto; 
    border-radius: 16px; 
    overflow:hidden; 
    min-height:0; 
    position:relative;
    box-shadow: var(--shadow-lg);
    border: 2px solid rgba(255, 255, 255, 0.3);
  }


  .dock{
    position:absolute; z-index:5; top:16px; left:16px;
    width: 380px; max-height: calc(100% - 32px);
    background: rgba(255, 255, 255, 0.55);
    backdrop-filter: blur(20px) saturate(180%);
    border: 1px solid rgba(255, 255, 255, 0.35);
    border-radius: 20px;
    box-shadow: var(--shadow-xl);
    overflow:hidden; 
    display:flex; 
    flex-direction:column;
    transition: transform 0.3s ease;
  }
  
  .dock:hover {
    transform: scale(1.01);
  }
  .dock.collapsed{
    width:auto; max-width: 50vw; height:auto; max-height:none;
    border-radius:999px; padding:8px 12px; gap:8px;
  }
  .dock.collapsed .dock-tools, .dock.collapsed #dockList{ display:none }
  .dock.collapsed .dock-header{ border:none; padding:0 }
  .dock-header{
    display:flex; align-items:center; justify-content:space-between;
    gap:10px; padding:14px 16px; 
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.15) 0%, rgba(118, 75, 162, 0.15) 100%);
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
    backdrop-filter: blur(5px);
  }
  .dock-title{ display:flex; align-items:center; gap:10px; font-weight:800; font-size: 18px; }
  .dock-title i { color: #667eea; }
  .dock-title small{ 
    color:var(--muted); 
    font-weight:700; 
    font-size: 14px;
    background: rgba(102, 126, 234, 0.1);
    padding: 4px 8px;
    border-radius: 12px;
  }
  .dock-actions .icon-btn{
    border: 1px solid rgba(102, 126, 234, 0.2); 
    background: rgba(255, 255, 255, 0.8); 
    border-radius: 10px;
    padding: 8px 10px; 
    cursor:pointer; 
    font-weight:700;
    transition: all 0.2s ease;
    color: #667eea;
  }
  .dock-actions .icon-btn:hover {
    background: rgba(102, 126, 234, 0.1);
    border-color: #667eea;
    transform: scale(1.05);
  }
  .dock-tools{ 
    display:flex; 
    flex-direction:column; 
    gap:10px; 
    padding:14px 16px; 
    background: rgba(255, 255, 255, 0.5);
  }
  #dockSearch{
    border: 1px solid rgba(102, 126, 234, 0.2); 
    background: rgba(255, 255, 255, 0.9); 
    border-radius: 12px;
    padding: 10px 14px; 
    font-weight:600; 
    width:100%;
    transition: all 0.2s ease;
  }
  #dockSearch:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    background: #fff;
  }
  .chips{ 
    display:flex; 
    gap:8px; 
    overflow:auto; 
    -webkit-overflow-scrolling: touch; 
    padding-bottom:4px;
    scrollbar-width: thin;
  }
  .chip{
    border: 1px solid rgba(102, 126, 234, 0.2); 
    background: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(247,250,252,0.9) 100%);
    color:var(--text);
    padding: 8px 14px; 
    border-radius: 20px; 
    font-weight:700; 
    white-space:nowrap; 
    cursor:pointer;
    transition: all 0.2s ease;
    font-size: 15px;
  }
  .chip:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-sm);
    border-color: rgba(102, 126, 234, 0.4);
  }
  .chip.ghost{ 
    background: rgba(255, 255, 255, 0.7);
    border-color: rgba(102, 126, 234, 0.15);
  }
  .chip.active{ 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-color: transparent;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    transform: translateY(-1px);
  }

  .dock-list{
    padding: 10px; 
    overflow:auto; 
    background: linear-gradient(180deg, rgba(255,255,255,0.6) 0%, rgba(247,250,252,0.6) 100%);
    border-top: 1px solid rgba(255, 255, 255, 0.3);
    scrollbar-width: thin;
  }
  .layer-card{
    display:grid; 
    grid-template-columns: 32px 1fr auto auto; 
    align-items:center; 
    gap:10px;
    background: rgba(255, 255, 255, 0.9); 
    border: 1px solid rgba(102, 126, 234, 0.15); 
    border-radius: 14px; 
    padding: 12px 14px; 
    margin: 8px 6px;
    box-shadow: var(--shadow-sm);
    transition: all 0.2s ease;
  }
  
  .layer-card:hover {
    transform: translateX(4px);
    box-shadow: var(--shadow-md);
    border-color: rgba(102, 126, 234, 0.3);
    background: #fff;
  }
  .layer-card .stripe{ width:24px; height:24px; border-radius:6px; display:flex; align-items:center; justify-content:center; font-size:16px; }
  .layer-card .name{ font-weight:900; line-height:1.2 }
  .layer-card .meta{ color:var(--muted); font-weight:700; font-size:1em }
  .layer-card .tools{ display:flex; gap:6px; }
  .icon-btn.small{
    border: 1px solid rgba(102, 126, 234, 0.2); 
    background: rgba(255, 255, 255, 0.9); 
    border-radius: 10px;
    padding: 6px 10px; 
    cursor:pointer; 
    font-weight:700;
    transition: all 0.2s ease;
    color: #667eea;
    font-size: 14px;
  }
  
  .icon-btn.small:hover {
    background: rgba(102, 126, 234, 0.1);
    border-color: #667eea;
    transform: scale(1.05);
  }


  .switch{ position:relative; width:42px; height:24px; }
  .switch input{ position:absolute; opacity:0; width:0; height:0; }
  .slider{
    position:absolute; inset:0; background:#e9edff; border:1px solid var(--border);
    border-radius:999px; transition:.15s;
  }
  .slider:before{
    content:""; position:absolute; height:18px; width:18px; left:3px; top:50%;
    transform:translateY(-50%); background:white; border-radius:50%; box-shadow:0 1px 2px rgba(0,0,0,.15);
    transition:.15s;
  }
  .switch input:checked + .slider{ 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-color: #667eea;
  }
  .switch input:checked + .slider:before{ 
    transform:translate(18px,-50%);
    box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
  }

  .kpis{ 
    display:grid; 
    grid-template-columns: repeat(3,1fr); 
    gap: 12px; 
    margin-top: 16px;
  }
  .kpi{ 
    background: linear-gradient(135deg, rgba(255,255,255,0.5) 0%, rgba(247,250,252,0.5) 100%);
    border: 1px solid rgba(255, 255, 255, 0.35);
    padding: 16px; 
    border-radius: 16px;
    box-shadow: var(--shadow-md);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    backdrop-filter: blur(10px);
  }
  
  .kpi::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
  }
  
  .kpi:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-lg);
  }
  
  .kpi .label{ 
    color:var(--muted); 
    font-size:12px; 
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
  }
  .kpi .value{ 
    font-size: 28px; 
    font-weight:800;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  /* Right */
  #mapProgress{ 
    height: 40%; 
    border-radius: 16px; 
    overflow:hidden; 
    min-height:0;
    box-shadow: var(--shadow-lg);
    border: 2px solid rgba(255, 255, 255, 0.3);
  }
  .charts{ 
    display:grid; 
    grid-template-columns: 0.8fr 1.2fr; 
    gap: 16px; 
    height: calc(60% - 16px); 
    min-height:0; 
    overflow:hidden;
    margin-top: 16px;
  }
  .chartbox{ 
    background: linear-gradient(135deg, rgba(255,255,255,0.5) 0%, rgba(247,250,252,0.5) 100%);
    border: 1px solid rgba(255, 255, 255, 0.35);
    border-radius: 18px; 
    padding: 16px; 
    position:relative; 
    overflow:hidden; 
    min-height:0;
    box-shadow: var(--shadow-md);
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
  }

  .chartbox .refresh-btn{
    position:absolute; right:12px; top:12px;
    padding:6px 10px; font-weight:900;
  }
  
  .chartbox:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
  }
  
  .chartbox canvas{ display:block; width:100% !important; height:100% !important; }
  
  #barChartFilter {
    border: 1px solid rgba(102, 126, 234, 0.2) !important;
    background: rgba(255, 255, 255, 0.95) !important;
    border-radius: 12px !important;
    padding: 10px 14px !important;
    font-weight: 700 !important;
    cursor: pointer !important;
    min-width: 200px !important;
    transition: all 0.2s ease;
    box-shadow: var(--shadow-sm);
  }
  
  #barChartFilter:focus {
    outline: none;
    border-color: #667eea !important;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1) !important;
  }


  /* Table */
  th.tbl-sort { cursor:pointer; user-select:none; padding:10px 12px; text-align:left; font-weight:900; color:#3a3f6e; border-bottom:1px solid var(--border); background:#f7f9ff }
  td.tbl-cell { padding:8px 12px; border-bottom:1px solid #f0f3ff; color:#1c2546; font-size:14px }
  tr:nth-child(even) td.tbl-cell { background:#fcfdff; }
  .btn{ border:1px solid var(--border); background:#fff; padding:8px 12px; border-radius:10px; font-weight:800; cursor:pointer; }
  .btn:active{ transform: translateY(1px); }


  .maplibregl-ctrl-scale { margin: 8px; }

  @media (max-width: 1200px){
    .app{ grid-template-columns: 1fr; grid-template-rows: 1fr 1fr; height: auto; min-height: calc(100vh - 64px); }
    #mapAssets{ min-height: 0; height: 100%; }
    #mapProgress{ height: 40%; min-height: 0; }
    .charts{ height: calc(60% - 10px); min-height: 0; }
    .card{ padding:10px; min-height: 0; }
    .dock{ width: min(92vw, 420px); }
  }
</style>
</head>
<body>
<header>
  <span>Salalah Project Progress </span>
  
</header>

<div class="app hidden">
  
  <section class="card" style="grid-column:1;">
    <h4>Assets Map</h4>

    <div id="mapAssets">
      
      <div id="layerDock" class="dock collapsed">
        <div class="dock-header">
          <div class="dock-title">
            <i class="fas fa-map" style="font-size:20px;"></i>
            <strong>Asset</strong>
            <small id="dockMeta">0 active</small>
          </div>
          <div class="dock-actions">
            <button id="dockCollapse" class="icon-btn" title="Collapse">â–¾</button>
          </div>
        </div>

        <div class="dock-tools">
          <input id="dockSearch" type="search" placeholder="Search assetsâ€¦" />
          <div id="groupChips" class="chips"></div>
          <div class="quick">
            <button id="dockAllOn"  class="chip ghost" type="button">Show all</button>
            <button id="dockAllOff" class="chip ghost" type="button">Hide all</button>
          </div>
        </div>

        <div id="dockList" class="dock-list"></div>
      </div>
    </div>

    <div class="kpis">
      <div class="kpi"><div class="label">Assets</div><div class="value" id="kpiAssets">0</div></div>
      <div class="kpi"><div class="label">Total Assets</div><div class="value" id="kpiTotalAssets">0</div></div>
      <div class="kpi"><div class="label">% Uncovered Area</div><div class="value" id="kpiUncovered">0%</div></div>
    </div>
  </section>


  <section class="card" style="grid-column:2;">
    <h4>Progress Coverage</h4>
    <div id="mapProgress"></div>

    <div class="charts">
      <div class="chartbox"><canvas id="areaChart"></canvas><button id="refreshArea" class="icon-btn small refresh-btn" title="Refresh coverage">â†»</button></div>
      <div class="chartbox" id="barBox">
        <div style="display:flex; justify-content:flex-end; align-items:center; margin-bottom:8px;">
          <select id="barChartFilter">
            <option value="__ALL__">All Groups</option>
          </select>
        </div>
        <canvas id="assetBar"></canvas>
      </div>

      
    </div>
  </section>
</div>

<script>

window.addEventListener('error', e=>{
  const b=document.createElement('div'); b.style.cssText='position:fixed;inset:12px;z-index:999999;background:#fff;color:#1a2242;border:1px solid #e6ebff;border-radius:12px;padding:14px;box-shadow:0 10px 20px rgba(0,0,0,.12);';
  b.innerHTML=`<b>JS Error</b><br>${e.message}<br><pre style="white-space:pre-wrap">${e.filename}:${e.lineno}:${e.colno}</pre>`;
  document.body.appendChild(b);
}, true);
</script>

<script>

const CENTER = [54.1, 17.02];
const baseStyle = 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json'; // token-free light

const PROCESSED_URL = 'data/Processed.geojson';
const REMAIN_URL    = 'data/Remaining.geojson';


async function loadJSON(u){ const r=await fetch(encodeURI(u)); if(!r.ok) throw new Error(u); return r.json(); }
async function loadText(u){ const r=await fetch(encodeURI(u)); if(!r.ok) throw new Error(u); return r.text(); }

function fitToFC(map, fc){
  try{ const bb=turf.bbox(fc);
    if (bb.every(Number.isFinite)) map.fitBounds([[bb[0],bb[1]],[bb[2],bb[3]]],{padding:30,duration:0});
  }catch{}
}

function displayNameFromFile(file){
  const base = file.replace(/\.geojson$/i,''); const parts = base.split('_');
  return (parts.length>1?parts.slice(1).join('_'):base).replace(/_/g,' ');
}
function groupOfFile(manifest, file){ for (const [g, arr] of Object.entries(manifest)) if (arr.includes(file)) return g; return 'Other'; }


async function findStreetFile(){
  const candidates = [
    'data/street.geojson','data/Street.geojson','data/STREET.geojson',
    'data/SLLstreet.geojson','data/SLLStreet.geojson',
    'data/roads.geojson','data/Roads.geojson','data/road.geojson','data/Road.geojson'
  ];
  for (const path of candidates){
    try{ 
      console.log('ðŸ” Trying street file:', path);
      const res = await fetch(path,{cache:'no-store'}); 
      if(res.ok){ 
        const j = await res.json(); 
        console.log('ðŸ“„ File loaded:', path, 'type:', j?.type, 'features:', j?.features?.length);
        if (j && j.type && (Array.isArray(j.features) ? j.features.length>=0 : true)) {
          // Check geometry type of first few features
          if (j.features && j.features.length > 0) {
            const geomTypes = j.features.slice(0, 5).map(f => f?.geometry?.type).filter(Boolean);
            console.log('ðŸ“ Sample geometry types:', geomTypes);
          }
          return {path, data:j}; 
        }
      }
    }catch(e){ 
      console.warn('âš ï¸ Failed to load', path, e.message); 

    }
  }
  throw new Error('No street file found in /data');
}
const GROUP_COLORS = { Utilities:'#2563eb', Health:'#ef4444', PublicSafety:'#9333ea', PublicFacilities:'#14b8a6',
  Education:'#f59e0b', RoadTransportation:'#6b7280', LandCover:'#22c55e', Hydrology:'#0ea5e9', Government:'#ef4444',
  TouristSites:'#f97316', Shopping:'#8b5cf6', FoodFacilities:'#fb923c', Financial:'#334155', Religion:'#7dd3fc',
  Automotive:'#10b981', UrbanPlanning:'#06b6d4', Other:'#94a3b8' };
const colorFor = (g)=>GROUP_COLORS[g]||GROUP_COLORS.Other;


const GROUP_ICONS = {
  Automotive:'fa-car', Education:'fa-graduation-cap', Financial:'fa-dollar-sign', FoodFacilities:'fa-utensils',
  Health:'fa-hospital', Hydrology:'fa-water', LandCover:'fa-tree', PublicFacilities:'fa-building',
  PublicSafety:'fa-shield-halved', RoadTransportation:'fa-road', Shopping:'fa-shopping-cart', TouristSites:'fa-umbrella-beach',
  UrbanPlanning:'fa-city', Utilities:'fa-bolt', Government:'fa-landmark', Religion:'fa-mosque', Other:'fa-map-marker-alt'
};


const ASSET_ICONS = {
 
  'GasStation': 'fa-gas-pump', 'Service_Stations': 'fa-wrench',
 
  'College': 'fa-graduation-cap', 'Nursery': 'fa-baby', 'Schools': 'fa-school', 'TrainingCenters': 'fa-chalkboard-teacher', 'University': 'fa-university',
  
  'ATMs': 'fa-money-bill', 'Banks': 'fa-university', 'Insurance': 'fa-shield-alt', 'MoneyExchange': 'fa-exchange-alt',
  
  'Bakery': 'fa-birthday-cake', 'Butcher': 'fa-drumstick-bite', 'Cafes': 'fa-coffee', 'Restaurants': 'fa-utensils',
 
  'Clinics': 'fa-clinic-medical', 'HealthCenters': 'fa-heartbeat', 'Hospitals': 'fa-hospital', 'Pharmacies': 'fa-pills',
  
  'Afalj': 'fa-stream', 'Dams': 'fa-dam',
  
  'Tree': 'fa-tree',
 
  'Azabah': 'fa-horse', 'CarRentalAgency': 'fa-car', 'Cemetery': 'fa-cross', 'churches': 'fa-church', 'CleaningServices': 'fa-broom', 'ConstructionOffice': 'fa-hard-hat',
  'Court': 'fa-gavel', 'EventHalls': 'fa-building', 'Florist': 'fa-seedling', 'GardenCenter': 'fa-spa', 'GovernmentOffice': 'fa-landmark',
  'Gym': 'fa-dumbbell', 'import_export_office': 'fa-globe', 'JewelryStore': 'fa-gem', 'ManpowerRecruitmentOffice': 'fa-users', 'Mosques': 'fa-mosque',
  'Museum': 'fa-museum', 'Optician': 'fa-glasses', 'Parks': 'fa-tree', 'PetStore': 'fa-paw', 'PhotographyStudio': 'fa-camera',
  'PostOffice': 'fa-envelope', 'PrintingStationeryStore': 'fa-print', 'PublicRestroom': 'fa-restroom', 'RegistrationOffice': 'fa-file-alt',
  'Resthouse': 'fa-bed', 'SportField': 'fa-futbol', 'Telecom_Provider': 'fa-broadcast-tower', 'VeterinaryPharmacy': 'fa-syringe',
  
  'CivilDefenseCenters': 'fa-shield-alt', 'PoliceStation': 'fa-shield-alt',
  
  'Bridges': 'fa-bridge', 'BusStops': 'fa-bus', 'ParkingLot': 'fa-parking', 'Roundabout': 'fa-circle', 'SLLstreet': 'fa-road', 'street': 'fa-road', 'TrafficSignals': 'fa-traffic-light',
 
  'Barbershop': 'fa-cut', 'ClothingStore': 'fa-tshirt', 'CosmeticsStore': 'fa-palette', 'Electronics': 'fa-plug', 'GroceryStore': 'fa-shopping-basket',
  'Hardware': 'fa-tools', 'Homegoods': 'fa-home', 'Laudary': 'fa-tshirt', 'ShoppingMall': 'fa-store', 'SuperMarket': 'fa-shopping-cart', 'Tailorshop': 'fa-cut',
 
  'Beaches': 'fa-umbrella-beach', 'Hotels': 'fa-hotel', 'Tomb': 'fa-monument', 'TourismAttractions': 'fa-camera-retro', 'Travel_Agencies': 'fa-plane',
  
  'LightPoles': 'fa-lightbulb', 'Manholes': 'fa-circle', 'OTC': 'fa-tower-broadcast'
};
const iconForAsset = (file) => {
  const base = file.replace(/\.geojson$/i, '').replace(/^[^_]+_/, '');
  return ASSET_ICONS[base] || ASSET_ICONS[file.replace(/\.geojson$/i, '')] || GROUP_ICONS.Other;
};
const iconFor = (g)=>GROUP_ICONS[g]||GROUP_ICONS.Other;


const WGS84 = 'EPSG:4326';
proj4.defs('EPSG:32639','+proj=utm +zone=39 +datum=WGS84 +units=m +no_defs +type=crs');
proj4.defs('EPSG:32640','+proj=utm +zone=40 +datum=WGS84 +units=m +no_defs +type=crs');
proj4.defs('EPSG:32641','+proj=utm +zone=41 +datum=WGS84 +units=m +no_defs +type=crs');
proj4.defs('EPSG:3857','+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +type=crs');

function pickSampleXY(geojson){
  const f = geojson?.features?.find(ft=>ft.geometry && ft.geometry.coordinates);
  if(!f) return null;
  const g=f.geometry, t=g.type;
  if (t==='Point') return g.coordinates;
  if (t==='MultiPoint') return g.coordinates?.[0];
  if (t==='LineString') return g.coordinates?.[0];
  if (t==='MultiLineString') return g.coordinates?.[0]?.[0];
  if (t==='Polygon') return g.coordinates?.[0]?.[0];
  if (t==='MultiPolygon') return g.coordinates?.[0]?.[0]?.[0];
  return null;
}


function detectCRS(geojson){
  
  const crsTag = geojson?.crs?.properties?.name || geojson?.crs?.name;
  if (crsTag && /EPSG:\d+/.test(crsTag)) return crsTag.toUpperCase();

  
  const xy = pickSampleXY(geojson);
  if (!xy || !Number.isFinite(xy[0]) || !Number.isFinite(xy[1])) return WGS84;

  const [x,y] = xy;

  
  if (x >= 52 && x <= 56 && y >= 15 && y <= 20) return 'EPSG:4326';

  
  if (Math.abs(x) > 1_000_000 && Math.abs(y) > 1_000_000) return 'EPSG:3857';

  
  const looksUTM = (x >= 100_000 && x <= 900_000 && y >= 0 && y <= 10_000_000);
  if (looksUTM){
    
    return 'EPSG:32640';
  }

 
  return WGS84;
}

function reprojectFC(fc, fromEPSG, toEPSG=WGS84){
  if (!fromEPSG || fromEPSG===toEPSG) return fc;
  const proj = proj4(fromEPSG, toEPSG);
  const out = { type:'FeatureCollection', features: [] };

  const mapCoords = (coords) => {
    if (!Array.isArray(coords)) return coords;
    if (typeof coords[0] === 'number') return proj.forward([coords[0], coords[1]]);
    return coords.map(mapCoords);
  };

  for (const f of (fc.features||[])){
    if (!f.geometry) { out.features.push(f); continue; }
    out.features.push({ ...f, geometry: { ...f.geometry, coordinates: mapCoords(f.geometry.coordinates) }});
  }
  return out;
}


const mapAssets = new maplibregl.Map({ container:'mapAssets', style:baseStyle, center:CENTER, zoom:11, minZoom:5, maxZoom:19 });
mapAssets.addControl(new maplibregl.NavigationControl(), 'top-right');
mapAssets.addControl(new maplibregl.ScaleControl({ maxWidth:160, unit:'metric' }), 'bottom-left');
mapAssets.setMaxBounds([[36,-5],[66,30]]); 

const mapProgress = new maplibregl.Map({ container:'mapProgress', style:baseStyle, center:CENTER, zoom:11, minZoom:5, maxZoom:19 });
mapProgress.addControl(new maplibregl.NavigationControl(), 'top-right');
mapProgress.addControl(new maplibregl.ScaleControl({ maxWidth:160, unit:'metric' }), 'bottom-left');
mapProgress.setMaxBounds([[36,-5],[66,30]]);


Chart.register(ChartDataLabels);
Chart.defaults.color = '#1a202c';
Chart.defaults.font.size = 16;
Chart.defaults.font.family = "'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif";
Chart.defaults.font.weight = '700';
Chart.defaults.plugins.legend.labels.color = '#4a5568';
Chart.defaults.plugins.legend.labels.font = { size: 15, weight:'700' };

const areaChart = new Chart(document.getElementById('areaChart').getContext('2d'), {
  type:'doughnut',
  data:{ labels:['Processed kmÂ²','Remaining kmÂ²'], datasets:[{ data:[0,0],
    backgroundColor:[
      '#71b084',  
      '#bca3c2'   
    ], borderWidth:0 }] },
  options:{ maintainAspectRatio:false, cutout:'38%', plugins:{ legend:{ position:'bottom' },
    datalabels:{ color:'#fff', font:{ weight:'1000', size:16 }, formatter:v => (typeof v==='number'? v.toFixed(2)+' kmÂ²':v) } } }
});
const assetBar = new Chart(document.getElementById('assetBar').getContext('2d'), {
  type:'bar',
  data:{ labels:[], datasets:[{ label:'Features', data:[], backgroundColor:[], borderRadius:10 }] },
  options:{ indexAxis:'y', maintainAspectRatio:false, plugins:{ legend:{ display:false } },
    scales:{ x:{ beginAtZero:true }, y:{ ticks:{ autoSkip:false } } } }
});


const featuresByLayer = new Map();   
const activeLayers = new Set();


function buildLayerDock(manifest, layerIds){
  const dock   = document.getElementById('layerDock');
  const listEl = document.getElementById('dockList');
  const metaEl = document.getElementById('dockMeta');
  const search = document.getElementById('dockSearch');
  const chips  = document.getElementById('groupChips');

  const groups = Object.keys(manifest);
  let groupFilter = '__ALL__';
  let query = '';

  function renderChips(){
    chips.innerHTML = '';
    const all = document.createElement('button');
    all.className = 'chip' + (groupFilter==='__ALL__' ? ' active' : '');
    all.textContent = 'All';
    all.onclick = () => { groupFilter='__ALL__'; renderList(); renderChips(); };
    chips.appendChild(all);

    groups.forEach(g=>{
      const btn = document.createElement('button');
      btn.className = 'chip' + (groupFilter===g ? ' active' : '');
      btn.textContent = g;
      btn.onclick = () => { groupFilter = (groupFilter===g?'__ALL__':g); renderList(); renderChips(); };
      chips.appendChild(btn);
    });
  }

  function model(){
    const rows = [];
    const excludeFiles = ['GeologyFormation.geojson', 'SoilType.geojson', 'Swamp.geojson', 'Water_Spread.geojson', 'Streams.geojson', 'LandUse.geojson', 'Intersections.geojson', 'Village.geojson', 'GroceryStore.geojson'];
    for (const [group, files] of Object.entries(manifest)){
      for (const file of files){
        
        if (excludeFiles.includes(file)) continue;
        
        const name = displayNameFromFile(file);
        const lyr  = `lyr_${name.replace(/\s+/g,'_')}`;
        const feats = featuresByLayer.get(lyr) || [];
        rows.push({
          id: lyr, name, group, color: colorFor(group), count: feats.length, on: activeLayers.has(lyr)
        });
      }
    }
    return rows;
  }

  function renderList(){
    const data = model()
      .filter(r => groupFilter==='__ALL__' || r.group===groupFilter)
      .filter(r => !query || r.name.toLowerCase().includes(query));

    data.sort((a,b)=>{
      if (a.on!==b.on) return a.on ? -1 : 1;
      if (b.count!==a.count) return b.count - a.count;
      return a.name.localeCompare(b.name, undefined, { numeric:true });
    });

    listEl.innerHTML = '';
    for (const r of data){
      const card = document.createElement('div');
      card.className = 'layer-card';

      const stripe = document.createElement('div');
      stripe.className = 'stripe';
      stripe.style.background = r.color;
      const iconEl = document.createElement('i');
      
      let assetIcon = GROUP_ICONS.Other;
      for (const [group, files] of Object.entries(manifest)) {
        for (const file of files) {
          const clean = displayNameFromFile(file);
          const lyrId = `lyr_${clean.replace(/\s+/g,'_')}`;
          if (lyrId === r.id) {
            assetIcon = iconForAsset(file);
            break;
          }
        }
        if (assetIcon !== GROUP_ICONS.Other) break;
      }
      iconEl.className = 'fas ' + assetIcon;
      iconEl.style.color = '#fff';
      iconEl.style.fontSize = '14px';
      stripe.appendChild(iconEl);
      card.appendChild(stripe);

      const name = document.createElement('div');
      name.className = 'name';
      name.textContent = r.name;
      card.appendChild(name);

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.textContent = r.count.toLocaleString();
      card.appendChild(meta);

      const tools = document.createElement('div');
      tools.className = 'tools';

      
      const sw = document.createElement('label');
      sw.className = 'switch';
      sw.innerHTML = `<input type="checkbox" ${r.on?'checked':''}><span class="slider"></span>`;
      const cb = sw.querySelector('input');
      cb.onchange = () => {
        const on = cb.checked;
        
        const isHiddenLayer = /^(lyr_Manholes|lyr_LightPoles|lyr_Tree|lyr_street|lyr_SLLstreet)$/i.test(r.id);
        if (isHiddenLayer) {
         
          if (on) activeLayers.add(r.id); else activeLayers.delete(r.id);
          updateKpis(); metaEl.textContent = `${activeLayers.size} active`;
          return;
        }
        
        if (mapAssets._markersByLayer && mapAssets._markersByLayer.has(r.id)) {
          const markers = mapAssets._markersByLayer.get(r.id);
          markers.forEach(m => {
            const el = m.getElement();
            if (el) el.style.display = on ? '' : 'none';
          });
        } else {
          
          if (mapAssets.getLayer(r.id)) {
            mapAssets.setLayoutProperty(r.id,'visibility', on?'visible':'none');
          }
          if (mapAssets.getLayer(r.id + '_outline')) {
            mapAssets.setLayoutProperty(r.id + '_outline','visibility', on?'visible':'none');
          }
        }
        if (on) activeLayers.add(r.id); else activeLayers.delete(r.id);
        updateKpis(); metaEl.textContent = `${activeLayers.size} active`;
      };
      tools.appendChild(sw);

      
      const zoomBtn = document.createElement('button');
      zoomBtn.className = 'icon-btn small';
      zoomBtn.textContent = 'Zoom';
      zoomBtn.title = 'Zoom to layer';
      zoomBtn.onclick = ()=>{
        const feats = featuresByLayer.get(r.id) || [];
        if (!feats.length) return;
        fitToFC(mapAssets, { type:'FeatureCollection', features: feats });
      };
      tools.appendChild(zoomBtn);

      card.appendChild(tools);
      listEl.appendChild(card);
    }

    metaEl.textContent = `${activeLayers.size} active`;
  }

  
  search.addEventListener('input', e => { query = (e.target.value||'').toLowerCase(); renderList(); });
  document.getElementById('dockAllOn').onclick  = ()=>{ 
    layerIds.forEach(id=>{
      
      const isHiddenLayer = /^(lyr_Manholes|lyr_LightPoles|lyr_Tree|lyr_street|lyr_SLLstreet)$/i.test(id);
      if (isHiddenLayer) {
        activeLayers.add(id);
        return;
      }
      // Handle markers
      if (mapAssets._markersByLayer && mapAssets._markersByLayer.has(id)) {
        const markers = mapAssets._markersByLayer.get(id);
        markers.forEach(m => {
          const el = m.getElement();
          if (el) el.style.display = '';
        });
      } else {
        if (mapAssets.getLayer(id)) {
          mapAssets.setLayoutProperty(id,'visibility','visible');
        }
        if (mapAssets.getLayer(id + '_outline')) {
          mapAssets.setLayoutProperty(id + '_outline','visibility','visible');
        }
      }
      activeLayers.add(id);
    });
    updateKpis(); renderList();
  };
  document.getElementById('dockAllOff').onclick = ()=>{
    layerIds.forEach(id=>{
      // Skip Manholes, LightPoles, Tree, and street (not rendered on map)
      const isHiddenLayer = /^(lyr_Manholes|lyr_LightPoles|lyr_Tree|lyr_street|lyr_SLLstreet)$/i.test(id);
      if (isHiddenLayer) {
        activeLayers.delete(id);
        return;
      }
      // Handle markers
      if (mapAssets._markersByLayer && mapAssets._markersByLayer.has(id)) {
        const markers = mapAssets._markersByLayer.get(id);
        markers.forEach(m => {
          const el = m.getElement();
          if (el) el.style.display = 'none';
        });
      } else {
        if (mapAssets.getLayer(id)) {
          mapAssets.setLayoutProperty(id,'visibility','none');
        }
        if (mapAssets.getLayer(id + '_outline')) {
          mapAssets.setLayoutProperty(id + '_outline','visibility','none');
        }
      }
      activeLayers.delete(id);
    });
    updateKpis(); renderList();
  };
  document.getElementById('dockCollapse').onclick = ()=>{
    const dock = document.getElementById('layerDock');
    dock.classList.toggle('collapsed');
    document.getElementById('dockCollapse').textContent = dock.classList.contains('collapsed') ? 'â–¸' : 'â–¾';
  };

  // Update KPIs function - needs access to layerIds length
  function updateKpis() {
    // Assets = number of layers (total layers available)
    const layersCount = layerIds.length || totalLayersGlobal || 0;
    document.getElementById('kpiAssets').textContent = layersCount.toLocaleString();
    
    // Total Assets = total features across all layers
    let totalFeatures = 0;
    featuresByLayer.forEach((feats) => {
      totalFeatures += feats.length;
    });
    document.getElementById('kpiTotalAssets').textContent = totalFeatures.toLocaleString();
    
  }

  renderChips();
  renderList();
  updateKpis(); // Initial update
}

/* ====== Boot ====== */
(async function boot(){
  // maps ready
  await new Promise(res => mapAssets.once('load', res));
  await new Promise(res => mapProgress.once('load', res));

  // manifest (your layer names & files)
  let manifest={}; try{ manifest = await loadJSON('manifest.json'); }catch(e){ console.warn('No manifest.json', e); }

  // coverage layers (both maps)
  let processed={type:'FeatureCollection',features:[]}, remaining={type:'FeatureCollection',features:[]};
  try{ 
    processed = await loadJSON(PROCESSED_URL);
    console.log('âœ… Loaded Processed.geojson:', processed.features?.length || 0, 'features');
  }catch(e){
    console.error('âŒ Failed to load Processed.geojson:', e);
  }
  try{ 
    remaining = await loadJSON(REMAIN_URL);
    console.log('âœ… Loaded Remaining.geojson:', remaining.features?.length || 0, 'features');
  }catch(e){
    console.error('âŒ Failed to load Remaining.geojson:', e);
  }

  function repro(fc){ const epsg = detectCRS(fc); return epsg==='EPSG:4326' ? fc : reprojectFC(fc, epsg, 'EPSG:4326'); }

  // Add to right map (Progress Coverage)
  console.log('ðŸ—ºï¸ Adding Processed and Remaining to right map (Progress Coverage)');
  console.log('Initial processed features:', processed?.features?.length || 0);
  console.log('Initial remaining features:', remaining?.features?.length || 0);
  
  let processedForRight = processed;
  let remainingForRight = remaining;
  
  // Ensure maps are fully loaded before adding layers
  await new Promise(resolve => setTimeout(resolve, 100));
  
  if (processed && processed.features && processed.features.length > 0){ 
    processedForRight = repro(processed);
    console.log('âœ… Processed features after reprojection:', processedForRight.features.length);
    try {
      // Remove existing source/layer if present
      if (mapProgress.getSource('processed')) {
        if (mapProgress.getLayer('processed')) mapProgress.removeLayer('processed');
        mapProgress.removeSource('processed');
      }
      mapProgress.addSource('processed', { type:'geojson', data:processedForRight });
      mapProgress.addLayer({ id:'processed', type:'fill', source:'processed',
        paint:{ 'fill-color':'#71b084', 'fill-opacity':0.45, 'fill-outline-color':'#94a3b8' },
        layout: { 'visibility': 'visible' }});
      console.log('âœ… Processed layer added to right map - visibility:', mapProgress.getLayoutProperty('processed', 'visibility'));
    } catch (e) {
      console.error('âŒ Error adding processed layer to right map:', e);
    }
  } else {
    console.warn('âš ï¸ No processed features to add');
  }
  
  // Force load remaining even if it seems empty
  if (remaining){
    if (!remaining.features || remaining.features.length === 0) {
      console.warn('âš ï¸ Remaining has no features, attempting to reload...');
      try {
        const reloaded = await loadJSON(REMAIN_URL);
        if (reloaded && reloaded.features && reloaded.features.length > 0) {
          remaining = reloaded;
          console.log('âœ… Reloaded remaining.geojson:', remaining.features.length, 'features');
        }
      } catch (reloadErr) {
        console.error('âŒ Failed to reload remaining.geojson:', reloadErr);
      }
    }
    
    if (remaining.features && remaining.features.length > 0){ 
      remainingForRight = repro(remaining);
      console.log('âœ… Remaining features after reprojection:', remainingForRight.features.length);
      try {
        // Remove existing source/layer if present
        if (mapProgress.getSource('remaining')) {
          if (mapProgress.getLayer('remaining')) mapProgress.removeLayer('remaining');
          mapProgress.removeSource('remaining');
        }
        mapProgress.addSource('remaining', { type:'geojson', data:remainingForRight });
        mapProgress.addLayer({ id:'remaining', type:'fill', source:'remaining',
          paint:{ 'fill-color':'#bca3c2', 'fill-opacity':0.40, 'fill-outline-color':'#94a3b8' },
          layout: { 'visibility': 'visible' }});
        console.log('âœ… Remaining layer added to right map - visibility:', mapProgress.getLayoutProperty('remaining', 'visibility'));
        console.log('âœ… Remaining source exists:', mapProgress.getSource('remaining') ? 'YES' : 'NO');
        console.log('âœ… Remaining layer exists:', mapProgress.getLayer('remaining') ? 'YES' : 'NO');
      } catch (e) {
        console.error('âŒ Error adding remaining layer to right map:', e);
        console.error('Error details:', e.message, e.stack);
      }
    } else {
      console.error('âŒ Remaining.geojson is empty or invalid. Features:', remaining?.features?.length || 0);
      console.error('Remaining object keys:', remaining ? Object.keys(remaining) : 'null/undefined');
    }
  } else {
    console.error('âŒ Remaining object is null or undefined');
  }
  
  // Use reprojected versions for map fitting and calculations
  processed = processedForRight;
  remaining = remainingForRight;
  
  const allCov = { type:'FeatureCollection', features:[...processed.features, ...remaining.features] };
  if (allCov.features.length) {
    fitToFC(mapProgress, allCov);
    console.log('âœ… Right map fitted to coverage bounds');
  }

  // Add to left map (Assets Map) - add before assets so assets render on top
  if (processed && processed.features && processed.features.length > 0){
    mapAssets.addSource('processed_assets', { type:'geojson', data:processed });
    mapAssets.addLayer({ id:'processed_assets', type:'fill', source:'processed_assets',
      paint:{ 'fill-color':'var(--processed)', 'fill-opacity':0.25, 'fill-outline-color':'#94a3b8' }});
  }
  if (remaining && remaining.features && remaining.features.length > 0){
    mapAssets.addSource('remaining_assets', { type:'geojson', data:remaining });
    mapAssets.addLayer({ id:'remaining_assets', type:'fill', source:'remaining_assets',
      paint:{ 'fill-color':'var(--remaining)', 'fill-opacity':0.20, 'fill-outline-color':'#94a3b8' }});
  }

  // Donut values - use 'area' field from properties (showing kmÂ²)
  // IMPORTANT: Use the reprojected versions (processed and remaining) for calculations
  console.log('ðŸ” Starting area calculations for doughnut chart...');
  console.log('Processed object:', processed ? 'exists' : 'null');
  console.log('Remaining object:', remaining ? 'exists' : 'null');
  let p=0,r=0;
  
  // Helper function to find area field case-insensitively
  function getAreaValue(feature) {
    if (!feature || !feature.properties) return null;
    const props = feature.properties;
    // Try common area field names (case-insensitive) - check for exact matches first
    const exactMatches = ['area', 'Area', 'AREA'];
    for (const key of exactMatches) {
      if (props.hasOwnProperty(key)) {
        const area = props[key];
        if (area != null && !isNaN(area) && area > 0) {
          console.log(`âœ… Found exact area field: ${key} = ${area}`);
          return parseFloat(area);
        }
      }
    }
    // Try case-insensitive search
    const areaKeys = Object.keys(props).filter(k => /^area$/i.test(k));
    if (areaKeys.length > 0) {
      const area = props[areaKeys[0]];
      if (area != null && !isNaN(area) && area > 0) {
        console.log(`âœ… Found area field (case-insensitive): ${areaKeys[0]} = ${area}`);
        return parseFloat(area);
      }
    }
    // Debug: show what properties exist
    if (Object.keys(props).length > 0) {
      console.log(`âš ï¸ No area field found. Available properties:`, Object.keys(props));
    }
    return null;
  }
  
  // Calculate processed area from properties
  console.log('ðŸ“Š Calculating processed area...');
  console.log('Processed features count:', processed.features?.length || 0);
  let processedAreaCount = 0;
  let processedSampleArea = null;
  if (processed && processed.features && processed.features.length > 0) {
    processed.features.forEach((f, idx)=> { 
      const area = getAreaValue(f);
      if (area != null) {
        if (processedSampleArea === null) {
          processedSampleArea = area;
          console.log(`ðŸ“Š Processed: First area value found at feature ${idx}: ${area}`);
        }
        // If area >= 100000 (100k), assume it's in mÂ² and convert to kmÂ², otherwise assume kmÂ²
        // This handles cases where values are already in kmÂ² (like 86, 177) or large values in mÂ²
        // Using 100000 as threshold because kmÂ² values are typically < 1000, while mÂ² for large areas are > 100000
        const areaKm2 = area >= 100000 ? area / 1e6 : area;
        p += areaKm2;
        processedAreaCount++;
      }
    });
  }
  console.log(`ðŸ“Š Processed: Found area field in ${processedAreaCount} out of ${processed.features?.length || 0} features`);
  console.log(`ðŸ“Š Processed: Total area = ${p.toFixed(2)} kmÂ²`);
  if (processedSampleArea !== null) {
    console.log(`ðŸ“Š Processed: Sample area value: ${processedSampleArea} (${processedSampleArea >= 100000 ? 'converting from mÂ² to kmÂ²' : 'using as kmÂ²'})`);
  }
  
  // Calculate remaining area from properties
  console.log('ðŸ“Š Calculating remaining area...');
  console.log('Remaining features count:', remaining.features?.length || 0);
  let remainingAreaCount = 0;
  let remainingSampleArea = null;
  if (remaining && remaining.features && remaining.features.length > 0) {
    // Show first feature properties for debugging
    if (remaining.features[0] && remaining.features[0].properties) {
      console.log('ðŸ“Š Remaining: First feature properties:', Object.keys(remaining.features[0].properties));
      console.log('ðŸ“Š Remaining: First feature property values:', remaining.features[0].properties);
    }
    remaining.features.forEach((f, idx)=> { 
      const area = getAreaValue(f);
      if (area != null) {
        if (remainingSampleArea === null) {
          remainingSampleArea = area;
          console.log(`ðŸ“Š Remaining: First area value found at feature ${idx}: ${area}`);
        }
        // If area >= 100000 (100k), assume it's in mÂ² and convert to kmÂ², otherwise assume kmÂ²
        // This handles cases where values are already in kmÂ² (like 86) or large values in mÂ²
        // Using 100000 as threshold because kmÂ² values are typically < 1000, while mÂ² for large areas are > 100000
        const areaKm2 = area >= 100000 ? area / 1e6 : area;
        r += areaKm2;
        remainingAreaCount++;
      }
    });
  } else {
    console.error('âŒ Remaining features array is empty or invalid!');
    console.error('Remaining object:', remaining);
  }
  console.log(`ðŸ“Š Remaining: Found area field in ${remainingAreaCount} out of ${remaining.features?.length || 0} features`);
  console.log(`ðŸ“Š Remaining: Total area = ${r.toFixed(2)} kmÂ²`);
  if (remainingSampleArea !== null) {
    console.log(`ðŸ“Š Remaining: Sample area value: ${remainingSampleArea} (${remainingSampleArea >= 100000 ? 'converting from mÂ² to kmÂ²' : 'using as kmÂ²'})`);
  }
  
  // Debug: show sample properties if no area found
  if (processedAreaCount === 0 && processed.features && processed.features.length > 0) {
    console.log('âš ï¸ Processed - Sample properties:', Object.keys(processed.features[0].properties || {}));
  }
  if (remainingAreaCount === 0 && remaining.features && remaining.features.length > 0) {
    console.log('âš ï¸ Remaining - Sample properties:', Object.keys(remaining.features[0].properties || {}));
    console.log('âš ï¸ Remaining - Sample property values:', remaining.features[0].properties);
  }
  
  // Fallback to geometry calculation if no area field found
  if ((p+r)===0){ 
    console.log('No area field found in properties, falling back to geometry calculation');
    processed.features.forEach(f=>{ if (/Polygon/i.test(f.geometry?.type)) p+=turf.area(f)/1e6; });
    remaining.features.forEach(f=>{ if (/Polygon/i.test(f.geometry?.type)) r+=turf.area(f)/1e6; });
    if ((p+r)===0){ 
      areaChart.data.labels=['Processed (count)','Remaining (count)']; 
      p=processed.features.length; 
      r=remaining.features.length; 
      areaChart.options.plugins.datalabels.formatter = v => v; 
    }
  }
  
  console.log('ðŸ“Š Doughnut Chart Values:', { processed: p.toFixed(2) + ' kmÂ²', remaining: r.toFixed(2) + ' kmÂ²' });
  
  // Update doughnut chart with kmÂ² values
  areaChart.data.labels = ['Processed kmÂ²', 'Remaining kmÂ²'];
  areaChart.data.datasets[0].data = [+(p.toFixed(2)), +(r.toFixed(2))];
  areaChart.options.plugins.datalabels.formatter = v => (typeof v==='number'? v.toFixed(2)+' kmÂ²':v);
  areaChart.update();
  
  // Calculate % Remaining Area (Uncovered Area)
  const totalArea = p + r;
  const uncoveredPct = totalArea > 0 ? Math.round((r / totalArea) * 100) : 0;
  console.log('ðŸ“Š % Remaining Area:', uncoveredPct + '%');
  document.getElementById('kpiUncovered').textContent = uncoveredPct + '%';

  // Left: assets map from manifest
  const clickable=[]; const layerIds=[]; let totalLayers=0;
  // Assets data for bar chart: {assetName: count}
  const assetCounts = new Map();

  // Files to exclude
  const excludeFiles = ['GeologyFormation.geojson', 'SoilType.geojson', 'Swamp.geojson', 'Water_Spread.geojson', 'Streams.geojson', 'LandUse.geojson', 'Intersections.geojson', 'Village.geojson', 'GroceryStore.geojson'];

  for (const [group, files] of Object.entries(manifest)){
    for (const file of files){
      // Skip excluded files
      if (excludeFiles.includes(file)) continue;
      
      totalLayers++;
      // Handle street file: robust filename search
      let filePath = `data/${file}`;
      let actualFile = file;
      let raw;
      
      // Special handling for street files - try to find the file with multiple name variations
      const isStreetFile = /^(SLLstreet|street)$/i.test(file.replace(/\.geojson$/i,''));
      if (isStreetFile){
        try{
          const found = await findStreetFile();
          filePath = found.path; 
          actualFile = filePath.split('/').pop();
          raw = found.data; // already loaded JSON
          console.log('âœ… Street file found:', filePath, 'features:', raw.features?.length);
        }catch(e){
          console.warn('Street search failed, trying manifest path', e);
          // Fall through to normal loading
          try {
            raw = await loadJSON(filePath);
            console.log('Loaded street file from manifest path:', filePath, 'features:', raw.features?.length);
          } catch(e2) {
            console.warn('Failed to load street file:', filePath, e2);
            continue;
          }
        }
      } else {
        // Normal file loading for non-street files
        try{ 
          raw = await loadJSON(filePath);
        }catch(e){ 
          console.warn('Failed to load', filePath, e); 
          continue;
        }
      }

      // === NEW: robust per-layer reprojection ===
      let srcCrs = detectCRS(raw);
      if (srcCrs !== 'EPSG:4326') {
        console.log('Reprojecting', actualFile, 'from', srcCrs, 'â†’ EPSG:4326');
      }
      let data = reprojectFC(raw, srcCrs, 'EPSG:4326');

// Guard: if still not looking like lon/lat, fall back to raw
try {
  const g0 = data?.features?.[0]?.geometry;
  let x;
  if (g0?.type==='LineString') x = g0.coordinates?.[0]?.[0];
  else if (g0?.type==='MultiLineString') x = g0.coordinates?.[0]?.[0]?.[0];
  else if (g0?.type==='Point') x = g0.coordinates?.[0];
  else if (g0?.type==='Polygon') x = g0.coordinates?.[0]?.[0]?.[0];
  if (x!=null && Math.abs(x) > 180) { console.warn('Reprojection suspicious for', actualFile, 'â†’ using raw'); data = raw; }
} catch (err) {
  console.warn('Reprojection guard error:', err);
}

// If reprojection produced 0 features but raw had some, prefer raw
if ((!data?.features || data.features.length===0) && (raw?.features?.length>0)) {
  console.warn('Reprojection yielded 0 features; using raw features for', actualFile);
  data = raw;
}

// Check if data is valid
      if (!data || !data.features || data.features.length === 0) {
        console.warn('Empty data after reprojection for:', file, 'raw features:', raw.features?.length);
        continue;
      }

      // CRITICAL: Use the original file name from manifest for layer ID consistency
      // This ensures the layer ID matches what model() expects
      const cleanManifest = displayNameFromFile(file); // Use original manifest file name
      const clean = displayNameFromFile(actualFile || file);
      const src=`src_${file}`; 
      const lyr=`lyr_${cleanManifest.replace(/\s+/g,'_')}`; // Use manifest name for layer ID
      const color = colorFor(groupOfFile(manifest, file));
      
      // Debug: ensure we're using consistent IDs
      if (isStreetFile || file.toLowerCase().includes('street')) {
        console.log('ðŸ”§ LAYER ID CONSISTENCY FIX:');
        console.log('  - Manifest file:', file);
        console.log('  - Actual file:', actualFile);
        console.log('  - Clean manifest name:', cleanManifest);
        console.log('  - Clean actual name:', clean);
        console.log('  - Layer ID (using manifest):', lyr);
      }
      
      // AGGRESSIVE geometry detection - prioritize LineString for street files
      let geomType = null;
      const geomTypesFound = new Set();
      
      // For street files, assume LineString and verify
      if (isStreetFile || file.toLowerCase().includes('street')) {
        // Check first feature immediately
        if (data.features && data.features.length > 0) {
          const firstType = data.features[0]?.geometry?.type;
          if (firstType && (firstType === 'LineString' || firstType === 'MultiLineString')) {
            geomType = firstType;
            console.log('ðŸ›£ï¸ STREET: Detected geometry type from first feature:', geomType);
          }
        }
      }
      
      // If not detected as Line yet, check thoroughly
      if (!geomType || !geomType.includes('Line')) {
        // Sample first 100 features to detect type (for performance with large files)
        const sampleSize = Math.min(data.features.length, 100);
        for (let i = 0; i < sampleSize; i++) {
          const f = data.features[i];
          if (f.geometry && f.geometry.type) {
            const t = f.geometry.type;
            geomTypesFound.add(t);
            if (t === 'LineString' || t === 'MultiLineString') { 
              geomType = t; 
              break; 
            }
          }
        }
      }
      
      // If still no Line found, check ALL features for street files
      if (isStreetFile && (!geomType || !geomType.includes('Line'))) {
        console.warn('âš ï¸ STREET: No LineString found in first 100, checking all features...');
        for (const f of data.features || []) {
          if (f.geometry && f.geometry.type) {
            const t = f.geometry.type;
            if (t === 'LineString' || t === 'MultiLineString') { 
              geomType = t; 
              console.log('âœ… STREET: Found LineString geometry at feature:', data.features.indexOf(f));
              break; 
            }
          }
        }
      }
      
      // If no Line found, check for Polygon, then Point
      if (!geomType) {
        for (const f of data.features || []) {
          if (f.geometry && f.geometry.type) {
            const t = f.geometry.type;
            if (t.includes('Polygon')) { 
              geomType = t; 
              break; 
            }
            if (t.includes('Point')) { 
              geomType = t; 
            }
          }
        }
      }
      if (!geomType) geomType = 'Point'; // fallback
      
      // CRITICAL: Force LineString for street files if we have data
      if ((isStreetFile || file.toLowerCase().includes('street')) && data.features && data.features.length > 0) {
        if (!geomType.includes('Line')) {
          console.warn('âš ï¸ STREET: Geometry not detected as LineString, forcing LineString for street file');
          geomType = 'LineString'; // Force it
        }
        console.log('ðŸ›£ï¸ STREET FINAL: Geometry type:', geomType, 'Features:', data.features.length);
      }

      mapAssets.addSource(src,{ type:'geojson', data });
      const group = groupOfFile(manifest, file);
      const icon = iconForAsset(file); // Use unique icon per asset
      
      // Skip map rendering for Manholes, LightPoles, Tree, and street (but keep in charts)
      const skipMapRendering = /^(Manholes|LightPoles|Tree|street|SLLstreet)$/i.test(file.replace(/\.geojson$/i, '')) || isStreetFile;
      
      // Enhanced debug for streets
      if (isStreetFile || file.toLowerCase().includes('street') || actualFile.toLowerCase().includes('street')) {
        console.log('=== ðŸ›£ï¸ STREET FILE DEBUG ===');
        console.log('Manifest file:', file, 'â†’ Actual file:', actualFile);
        console.log('File path used:', filePath);
        console.log('Raw features count:', raw.features?.length);
        console.log('After reprojection features:', data.features?.length);
        console.log('Geometry type detected:', geomType);
        if (data.features && data.features.length > 0) {
          const firstFeat = data.features[0];
          console.log('First feature:', JSON.stringify(firstFeat, null, 2));
          console.log('First feature geometry type:', firstFeat.geometry?.type);
          if (firstFeat.geometry?.coordinates) {
            const sampleCoords = firstFeat.geometry.type === 'LineString' 
              ? firstFeat.geometry.coordinates[0]
              : firstFeat.geometry.coordinates[0]?.[0] || firstFeat.geometry.coordinates;
            console.log('Sample coordinates:', sampleCoords);
          }
        }
        console.log('Layer ID:', lyr, 'Source ID:', src, 'Color:', color);
        console.log('Will add as LineString?', /Line/i.test(geomType));
      }
      
      if (!skipMapRendering && /Point/i.test(geomType)){
        // Use HTML markers with FA icons instead of circles
        const markers = [];
        for (const feature of data.features) {
          if (!feature.geometry) continue;
          const type = feature.geometry.type;
          const coordsArr = type === 'Point' ? [feature.geometry.coordinates] 
                                             : (type === 'MultiPoint' ? feature.geometry.coordinates : []);
          for (const coord of coordsArr) {
            const [lng, lat] = coord;
            const el = document.createElement('div');
            el.style.cssText = 'font-size:28px; text-align:center; cursor:pointer; color:' + color + '; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.7)); line-height:1;';
            const iconEl = document.createElement('i');
            iconEl.className = 'fas ' + icon;
            el.appendChild(iconEl);
            el.title = clean;
            const marker = new maplibregl.Marker({ element: el, anchor: 'center' })
              .setLngLat([lng, lat])
              .addTo(mapAssets);
            marker._layerId = lyr;
            markers.push(marker);

            el.addEventListener('click', (e) => {
              e.stopPropagation();
              const p = feature.properties || {};
              const keys = Object.keys(p);
              const assetIdKey = keys.find(k=>/asset[_\s]?id/i.test(k)) || keys.find(k=>/^id$/i.test(k));
              const nameKey = keys.find(k=>/^name$/i.test(k));
              const districtKey = keys.find(k=>/district/i.test(k));
              const wilayatKey = keys.find(k=>/wilayat|wlyt/i.test(k));
              const lines = [];
              if (assetIdKey && p[assetIdKey] != null) lines.push(`<div><b>Asset ID</b>: ${p[assetIdKey]}</div>`);
              if (nameKey && p[nameKey] != null) lines.push(`<div><b>Name</b>: ${p[nameKey]}</div>`);
              if (districtKey && p[districtKey] != null) lines.push(`<div><b>District</b>: ${p[districtKey]}</div>`);
              if (wilayatKey && p[wilayatKey] != null) lines.push(`<div><b>Wilayat</b>: ${p[wilayatKey]}</div>`);
              lines.push(`<div><b>Governorate</b>: Dhofar Governorate</div>`);
              lines.push(`<div><b>Lat</b>: ${lat.toFixed(6)}</div>`);
              lines.push(`<div><b>Long</b>: ${lng.toFixed(6)}</div>`);
              const html = `<div style="min-width:240px">
                <div style="font-weight:900;margin-bottom:6px;font-size:16px;color:#1f3ad9">${clean}</div>
                ${lines.join('')}
              </div>`;
              new maplibregl.Popup({ closeButton:true, maxWidth:'360px' })
                .setLngLat([lng, lat]).setHTML(html).addTo(mapAssets);
            });
          }
        }
        if (!mapAssets._markersByLayer) mapAssets._markersByLayer = new Map();
        mapAssets._markersByLayer.set(lyr, markers);
      } else if (!skipMapRendering && (/Line/i.test(geomType) || (isStreetFile && data.features && data.features.length > 0))){
        // CRITICAL: Force line rendering for streets
        console.log('ðŸ›£ï¸ ========== ADDING STREET LINE LAYERS ==========');
        console.log('Layer ID:', lyr, 'Source ID:', src);
        console.log('Features count:', data.features?.length);
        console.log('Geometry type:', geomType);
        console.log('Color:', color);
        
        // Wait a tiny bit to ensure source is ready
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Verify source exists and has data
        const source = mapAssets.getSource(src);
        if (!source) {
          console.error('âŒ CRITICAL: Source does not exist:', src);
          console.error('Attempting to add source again...');
          try {
            mapAssets.addSource(src, { type:'geojson', data });
            console.log('âœ… Re-added source:', src);
          } catch (sourceErr) {
            console.error('âŒ Failed to add source:', sourceErr);
          }
        } else {
          console.log('âœ… Source exists:', src);
          if (source._data) {
            console.log('Source data features:', source._data.features?.length);
          }
        }
        
        // Remove layers if they already exist (to avoid conflicts)
        try {
          if (mapAssets.getLayer(lyr)) {
            mapAssets.removeLayer(lyr);
            console.log('Removed existing layer:', lyr);
          }
          if (mapAssets.getLayer(lyr + '_outline')) {
            mapAssets.removeLayer(lyr + '_outline');
            console.log('Removed existing outline layer');
          }
        } catch (removeErr) {
          // Ignore if layers don't exist
        }
        
        try {
          // Add white outline layer FIRST with maximum visibility
          console.log('Adding outline layer...');
          mapAssets.addLayer({ 
            id:lyr + '_outline', 
            type:'line', 
            source:src, 
            paint:{ 
              'line-width': ['interpolate', ['linear'], ['zoom'], 
                6, 6,
                10, 10,
                14, 14,
                18, 18
              ],
              'line-color': '#ffffff',
              'line-opacity': 1.0,
              'line-cap': 'round',
              'line-join': 'round'
            },
            layout: { 
              'line-cap': 'round',
              'line-join': 'round',
              'visibility': 'visible'
            }
          });
          console.log('âœ… Outline layer added');
          
          // Add colored line layer on top with maximum visibility
          console.log('Adding main street layer...');
          mapAssets.addLayer({ 
            id:lyr, 
            type:'line', 
            source:src,
            paint:{ 
              'line-width': ['interpolate', ['linear'], ['zoom'], 
                6, 4,
                10, 6,
                14, 10,
                18, 14
              ],
              'line-color': color || '#1f2937',
              'line-opacity': 1.0,
              'line-cap': 'round',
              'line-join': 'round'
            },
            layout: { 
              'line-cap': 'round',
              'line-join': 'round',
              'visibility': 'visible'
            }
          });
          console.log('âœ… Main street layer added');
          
          // Verify layers were added
          const outlineLayer = mapAssets.getLayer(lyr + '_outline');
          const mainLayer = mapAssets.getLayer(lyr);
          
          console.log('Outline layer exists?', outlineLayer ? 'âœ… YES' : 'âŒ NO');
          console.log('Main layer exists?', mainLayer ? 'âœ… YES' : 'âŒ NO');
          
          if (outlineLayer) {
            console.log('Outline layer visibility:', mapAssets.getLayoutProperty(lyr + '_outline', 'visibility'));
          }
          if (mainLayer) {
            console.log('Main layer visibility:', mapAssets.getLayoutProperty(lyr, 'visibility'));
          }
          
          // FORCE visibility one more time
          if (mainLayer) {
            mapAssets.setLayoutProperty(lyr, 'visibility', 'visible');
            mapAssets.setLayoutProperty(lyr, 'line-opacity', 1.0);
          }
          if (outlineLayer) {
            mapAssets.setLayoutProperty(lyr + '_outline', 'visibility', 'visible');
            mapAssets.setLayoutProperty(lyr + '_outline', 'line-opacity', 1.0);
          }
          
          // Move to top of layer stack
          try {
            mapAssets.moveLayer(lyr + '_outline');
            mapAssets.moveLayer(lyr);
            console.log('âœ… Moved street layers to top');
          } catch (moveErr) {
            console.warn('âš ï¸ Could not move layers (might be already on top):', moveErr.message);
          }
          
          // Final verification
          setTimeout(() => {
            const finalOutline = mapAssets.getLayer(lyr + '_outline');
            const finalMain = mapAssets.getLayer(lyr);
            console.log('ðŸŽ¯ FINAL CHECK:');
            console.log('  Outline layer:', finalOutline ? 'âœ… EXISTS' : 'âŒ MISSING');
            console.log('  Main layer:', finalMain ? 'âœ… EXISTS' : 'âŒ MISSING');
            if (finalOutline) {
              console.log('  Outline visibility:', mapAssets.getLayoutProperty(lyr + '_outline', 'visibility'));
              console.log('  Outline opacity:', mapAssets.getPaintProperty(lyr + '_outline', 'line-opacity'));
            }
            if (finalMain) {
              console.log('  Main visibility:', mapAssets.getLayoutProperty(lyr, 'visibility'));
              console.log('  Main opacity:', mapAssets.getPaintProperty(lyr, 'line-opacity'));
              console.log('  Main color:', mapAssets.getPaintProperty(lyr, 'line-color'));
            }
          }, 100);
          
        } catch (err) {
          console.error('âŒ CRITICAL ERROR adding line layers:', err);
          console.error('Error stack:', err.stack);
          console.error('Source status:', mapAssets.getSource(src) ? 'EXISTS' : 'MISSING');
        }
      } else if (!skipMapRendering) {
        mapAssets.addLayer({ id:lyr, type:'fill', source:src, paint:{ 'fill-color':color, 'fill-opacity':0.35, 'fill-outline-color':'#fff' }});
      }

      // cache features/table - CRITICAL: use the same layer ID that's used in model()
      const feats = data.features||[]; 
      featuresByLayer.set(lyr, feats); 
      activeLayers.add(lyr);
      
      // Debug: log layer ID matching for streets
      if (isStreetFile || file.toLowerCase().includes('street')) {
        console.log('ðŸ”‘ STREET LAYER ID MATCH CHECK:');
        console.log('  - Created layer ID:', lyr);
        console.log('  - Clean name:', clean);
        console.log('  - File name:', file);
        console.log('  - Actual file:', actualFile);
        console.log('  - Features cached:', feats.length);
        console.log('  - featuresByLayer has this key?', featuresByLayer.has(lyr));
      }
      
      // Store asset count for bar chart with group info
      assetCounts.set(clean, {count: feats.length, group: group});
      
      // Special logging for street layer
      if (isStreetFile || file.toLowerCase().includes('street')) {
        console.log('ðŸ“Š Street layer summary:');
        console.log('  - Layer ID:', lyr);
        console.log('  - Features cached:', feats.length);
        console.log('  - Active:', activeLayers.has(lyr));
        console.log('  - Layer exists on map?', mapAssets.getLayer(lyr) ? 'YES' : 'NO');
        console.log('  - Outline exists?', mapAssets.getLayer(lyr + '_outline') ? 'YES' : 'NO');
        if (mapAssets.getLayer(lyr)) {
          console.log('  - Layer visibility:', mapAssets.getLayoutProperty(lyr, 'visibility'));
        }
        if (mapAssets.getLayer(lyr + '_outline')) {
          console.log('  - Outline visibility:', mapAssets.getLayoutProperty(lyr + '_outline', 'visibility'));
        }
        console.log('  - Source exists?', mapAssets.getSource(src) ? 'YES' : 'NO');
        if (mapAssets.getSource(src)) {
          const sourceData = mapAssets.getSource(src);
          console.log('  - Source type:', sourceData.type);
          if (sourceData._data) {
            console.log('  - Source features count:', sourceData._data.features?.length || 'unknown');
          }
        }
      }

      // Popup handler only for non-Point geometries (Point markers have inline handlers)
      // Skip popup handlers for Manholes and LightPoles since they're not rendered on map
      if (!skipMapRendering && !/Point/i.test(geomType)) {
        mapAssets.on('click', lyr, (e)=>{
          const f=e.features?.[0]; if(!f) return; const p={...(f.properties||{})};
          const keys = Object.keys(p);
          const assetIdKey = keys.find(k=>/asset[_\s]?id/i.test(k)) || keys.find(k=>/^id$/i.test(k));
          const nameKey = keys.find(k=>/^name$/i.test(k));
          const districtKey = keys.find(k=>/district/i.test(k));
          const wilayatKey = keys.find(k=>/wilayat|wlyt/i.test(k));
          
          const lines = [];
          if (assetIdKey && p[assetIdKey] != null) lines.push(`<div><b>Asset ID</b>: ${p[assetIdKey]}</div>`);
          if (nameKey && p[nameKey] != null) lines.push(`<div><b>Name</b>: ${p[nameKey]}</div>`);
          if (districtKey && p[districtKey] != null) lines.push(`<div><b>District</b>: ${p[districtKey]}</div>`);
          if (wilayatKey && p[wilayatKey] != null) lines.push(`<div><b>Wilayat</b>: ${p[wilayatKey]}</div>`);
          lines.push(`<div><b>Governorate</b>: Dhofar Governorate</div>`);
          lines.push(`<div><b>Lat</b>: ${e.lngLat.lat.toFixed(6)}</div>`);
          lines.push(`<div><b>Long</b>: ${e.lngLat.lng.toFixed(6)}</div>`);
          
          const html = `<div style="min-width:240px">
            <div style="font-weight:900;margin-bottom:6px;font-size:16px;color:#1f3ad9">${clean}</div>
            ${lines.join('')}
          </div>`;
          new maplibregl.Popup({ closeButton:true, maxWidth:'360px' }).setLngLat(e.lngLat).setHTML(html).addTo(mapAssets);
        });
      }

      // Only add to clickable and layerIds if rendered on map
      if (!skipMapRendering) {
        clickable.push(lyr); 
        if (/Line/i.test(geomType)) {
          clickable.push(lyr + '_outline'); // Also make outline clickable
        }
        layerIds.push(lyr);
      } else {
        // For Manholes and LightPoles, still add to layerIds so they appear in dock
        // but they won't be toggleable since there's nothing to show/hide
        layerIds.push(lyr);
      }
    }
  }

  // Fit to all (including processed and remaining)
  const allFeatures = Array.from(featuresByLayer.values()).flat();
  const allFC = { 
    type:'FeatureCollection', 
    features: [...allFeatures, ...(processed.features || []), ...(remaining.features || [])] 
  };
if (allFC.features.length) fitToFC(mapAssets, allFC);
else mapAssets.fitBounds([[52.5,16.5],[55.5,18.5]], { padding:30, duration:0 }); // fallback Salalah window

// If SLLstreet still has 0 features, surface a subtle in-app warning
try{
  const streetLyrId = Array.from(featuresByLayer.keys()).find(k=>/SLLstreet|street/i.test(k));
  if (streetLyrId && (featuresByLayer.get(streetLyrId)?.length||0)===0){
    const w = document.createElement('div');
    w.style.cssText='position:absolute;bottom:12px;left:12px;z-index:9;background:#fffbe6;border:1px solid #ffe58f;border-radius:10px;padding:8px 10px;box-shadow:0 4px 12px rgba(0,0,0,.08);font-weight:800;color:#7a5b00;';
    w.textContent='Street layer loaded with 0 features. Check file in /data and CRS.';
    document.getElementById('mapAssets').appendChild(w);
    setTimeout(()=>w.remove(), 6000);
  }
}catch{}

  // Build the floating Layer Dock
  buildLayerDock(manifest, layerIds);

  // Right bar chart - use GeoJSON feature counts with group filter
  let barChartFilter = '__ALL__';
  const allBarData = Array.from(assetCounts.entries())
    .map(([name, info]) => ({
      name,
      count: info.count,
      group: info.group,
      color: colorFor(info.group)
    }))
    .sort((a, b) => b.count - a.count);
  
  function updateBarChart() {
    const filtered = barChartFilter === '__ALL__' 
      ? allBarData 
      : allBarData.filter(d => d.group === barChartFilter);
    
    const barItems = filtered.slice(0, 20);
    
    assetBar.data.labels = barItems.map(d => d.name);
    assetBar.data.datasets[0].data = barItems.map(d => d.count);
    assetBar.data.datasets[0].backgroundColor = barItems.map(d => d.color);
    assetBar.update();
  }
  
  // Build bar chart filter dropdown
  const barFilterEl = document.getElementById('barChartFilter');
  const allGroups = Array.from(new Set(Array.from(assetCounts.values()).map(i => i.group))).sort();
  
  allGroups.forEach(group => {
    const option = document.createElement('option');
    option.value = group;
    option.textContent = group;
    barFilterEl.appendChild(option);
  });
  
  barFilterEl.addEventListener('change', (e) => {
    barChartFilter = e.target.value;
    updateBarChart();
  });
  
  updateBarChart();

  // Reveal
  setTimeout(()=>{ document.querySelector('.app')?.classList.remove('hidden'); doResize(); }, 60);

  // CRS auto-detect is now always on; no manual override UI
})();

/* ====== Resize helpers ====== */
function debounce(fn, ms=120){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }
function doResize(){ try { mapAssets.resize(); }catch{} try { mapProgress.resize(); }catch{} try { areaChart.resize(); }catch{} try { assetBar.resize(); }catch{} }
window.addEventListener('resize', debounce(doResize, 150));
window.addEventListener('orientationchange', doResize);
const ro = new ResizeObserver(debounce(doResize, 60));
['mapAssets','mapProgress','areaChart','assetBar'].forEach(id=>{
  const el = document.getElementById(id);
  if (id==='areaChart' || id==='assetBar') ro.observe(el?.parentElement); else ro.observe(el);
});
</script>
</body>
</html>


